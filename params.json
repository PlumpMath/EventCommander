{"name":"Eventcommander","tagline":"An EventBus, EventQueue, Command Pattern, and Undo-Redo library for Dart","body":"Event Commander\r\n===============\r\n\r\n[![Pub Package](http://img.shields.io/pub/v/box2d.svg?style=flat-square)](https://pub.dartlang.org/packages/event_commander)\r\n[![Build Status](https://drone.io/github.com/oblique63/EventCommander/status.png)](https://drone.io/github.com/oblique63/EventCommander/latest)\r\n\r\nAn EventBus, EventQueue, [Command Pattern](http://en.wikipedia.org/wiki/Command_pattern), and Undo-Redo library for [Dart](https://www.dartlang.org/).\r\n\r\n- [API Documentation](http://www.dartdocs.org/documentation/event_commander/latest)\r\n- [Changelog](https://github.com/oblique63/EventCommander/blob/master/CHANGELOG.md)\r\n\r\n#### TL;DR\r\n- The `EventBus` is in charge of firing, and sending `Events` to functions (i.e. `EventHandlers`)  you register.\r\n- You can make/compose your own `Event` types with multiple-inheritance so that `EventHandlers` can listen to subtypes of events.\r\n- An `EventQueue` is used whenever you want to queue up events of a certain type, and handle them sequentially.\r\n- Use `Commands` instead of `EventHandlers` when you want to keep track of the actions your application performs.\r\n- _Undo/Redo_ abilities are a nice bonus you get from using `Commands`, but require your commands to take a snapshot of\r\nthe changes performed to your objects using a `Map`.\r\n\r\n\r\n#### Conventions\r\nThroughout this doc, properties/methods of classes will be listed in the following format:\r\n\r\n`property_or_method : [modifiers] Type/ReturnType`\r\n\r\n\r\n## Event Bus\r\nThe `EventBus` is the backbone for all of the EventQueue/Command/Undo-Redo communications behind the scenes,\r\nbut may be used on its own to fire and listen to (a.k.a. 'publish/subscribe') Events.\r\n\r\n#### Basic usage\r\n\r\n```dart\r\nvar event_bus = new EventBus();\r\n\r\nevent_bus.on(MyEventType, (MyEventType event) => doSomething());\r\n\r\nevent_bus.signal(new MyEventType()); // doSomething() will be called\r\n```\r\n\r\nIdeally, only one instance of an `EventBus` object should be needed for each major scope of your application\r\n(e.g. client vs server). While using multiple instances is possible, it makes keeping track of events trickier,\r\nas there is no global/static EventBus object listening to everything (this is a design choice to allow for more flexibility).\r\nSo passing references to a single main `EventBus` instance is the preferred means of usage.\r\n\r\n#### EventHandler\r\nA function that accepts an `Event`, and is meant to be called whenever an event of the appropriate type is fired.\r\nNote: since `Events` allow for inheritance, `EventHandler` instances should not be reused to listen to multiple\r\nevents of the same super-type, since each EventHandler instance will only be called once per Event firing. Example:\r\n\r\n```dart\r\nmyEventHandler(MyEvent event) => doSomething();\r\n\r\n// Where MyChildEvent is a subtype of MyEvent\r\nevent_bus..on(MyEvent, myEventHandler)\r\n         ..on(MyChildEvent, myEventHandler);\r\n\r\nevent_bus.signal(MyChildEvent);\r\n// Will only call myEventHandler() once, despite other handlers for MyEvent\r\n// also being called.\r\n\r\n// To avoid this, simply assign a different function instance to each listener:\r\nevent_bus..on(MyEvent, (event) => doSomething())\r\n         ..on(MyChildEvent, (event) => doSomething());\r\n\r\nevent_bus.signal(MyChildEvent);\r\n// This time doSomething() will be called twice.\r\n```\r\n\r\n#### EventListener\r\n* `listens_to : Type` - Property that lists what type of `Event` the listener is listening to.\r\n\r\n* `handler : EventHandler` - The `EventHandler` function that is called whenever an `event` of the type\r\nspecified by `listens_to` is signaled.\r\n\r\n* `stopListening() : void` - Unregisters the listener from its corresponding `EventBus`, and stops the `handler`\r\nfrom being called and handling future events.\r\n\r\n#### EventBus\r\n* `on(Type event_type, void eventHandler(Event event)) : EventListener` -\r\nRegisters a function (`EventHandler`) to get called whenever an event of `event_type` is signaled.\r\nReturns an `EventListener` that can be used to stop the registered `EventHandler` from handling events.\r\n\r\n* `signal(Event event) : Future` -\r\nFires/propagates the event instance passed to it, and sends it to all the appropriate `EventHandlers` subscribed/listening\r\nto events of that type. Returns a `Future` in case some computation needs to happen after all the corresponding\r\n`EventHandlers` have been notified of the event.\r\n\r\n* `stopListener(EventListener listener) : void` -\r\nSame as `EventListener.stopListening()`. Unregisters an `EventHandler` function (via its corresponding `EventListener`)\r\nfrom the `EventBus`. Stops the `EventHandler` from being called and receiving future events from this `EventBus` instance.\r\n\r\n* `clearAllListeners() : void` -\r\nRemoves all `EventListeners`/`EventHandlers` from the `EventBus` instance.\r\n\r\n* `hasListener(EventListener listener) : bool` -\r\nChecks whether the given `listener` is registered with the `EventBus` instance.\r\n\r\n## Event Queue\r\n`EventQueue` is a basic [Event/Message Queue](http://gameprogrammingpatterns.com/event-queue.html) implementation\r\nthat populates itself based on `Events` sent to the `EventBus`. By default, an `EventQueue` will listen to all `Events`,\r\nbut each instance may be configured to only queue up specific event types upon creation:\r\n\r\n`var queue = new EventQueue(event_bus, queue_on: MyEvent);`\r\n\r\nAlternative declaration using generics (yields same result as above):\r\n\r\n`var queue = new EventQueue<MyEvent>(event_bus);`\r\n\r\n> __Note:__ Event types specified using generics will override any values passed to the 'queue_on' parameter\r\n\r\n#### Sample usage\r\n```dart\r\nwhile(true) {\r\n    if (event_queue.hasNext) {\r\n       Event event = event_queue.popNext();\r\n       doSomethingWith(event);\r\n\r\n       // Alternatively, you do not have to remove events\r\n       // from the queue to examine them:\r\n       checkEvent(event_queue.peekNext());\r\n    }\r\n    // break out of the loop under some condition...\r\n}\r\n\r\nif (event_queue.isActive)\r\n    event_queue.stopReceivingEvents();\r\n```\r\n\r\n## Events\r\nCustom Events may be created by sub-classing the `Event` class, and may contain any assortment\r\nof properties and behaviors like you would find in a regular Dart class.\r\n\r\n```dart\r\nclass MyEvent extends Event {\r\n  String description;\r\n  MyEvent(this.description);\r\n}\r\n\r\nevent_bus.on(MyEvent, (event) => doSomething());\r\n\r\nevent_bus.signal(new MyEvent('Something happened!')):\r\n```\r\n\r\nNotice that new instances of your Events should be created every time they're being signaled. This is because\r\nmodifying/reusing the same _exact_ instance of an `Event` object will break the expected functionality of `EventQueues`\r\n(i.e. queueing up the same instance twice and modifying its state, effectively overwrites the event's history, since `EventQueue`\r\ndoes not keep track of `Event` states and only contains references to the original event objects signaled).\r\nAdditionally, creating events is cheap, and guarding against signaling duplicate event instances helps catch bugs due to\r\naccidental event firings. The `EventBus` will display a warning whenever it catches an `Event` instance getting\r\nsignaled multiple times.\r\n\r\n> __Note:__ The `Event` super-class currently comes with a `dispatched : bool` property that signifies when the event\r\n> instance has been sent out to its respective listeners. It can be manually set after each use to overcome the\r\n> 'new-instance-per-signal()' policy, but doing so will break `EventQueues` as explained above. This feature is liable\r\n> to be deprecated in future versions, so avoid usage of it at all costs.\r\n\r\nEvents also support a multiple-inheritance scheme whereby listeners for a particular Event Type\r\nmay be notified of other Events implementing/extending that same Event Type. This is accomplished\r\nby adding super-class/parent events to a `Set<Type> parents` property in your `Event` class. Example:\r\n\r\n```dart\r\nclass MyEvent extends Event {\r\n  String description;\r\n  MyEvent(this.description);\r\n}\r\n\r\nclass MyOtherEvent extends Event {\r\n  int number;\r\n  MyOtherEvent(this.number);\r\n}\r\n\r\n// Class must commit to 'implement' MyElement and MyOtherElement to ensure that\r\n// listeners of those events can make use of this event\r\nclass MultiEvent extends Event implements MyEvent, MyOtherElement {\r\n  int number;\r\n  String description;\r\n\r\n  MyChildEvent(this.number, this.description) {\r\n    // This is what will notify listeners of MyEvent and MyOtherEvent\r\n    // whenever this event is called:\r\n    this.parents.addAll([MyEvent, MyOtherEvent]);\r\n  }\r\n}\r\n\r\nevent_bus.on(MyEvent, (MyEvent e) => doA(e.description));\r\nevent_bus.on(MyOtherEvent, (MyOtherEvent e) => doB(e.number));\r\n\r\nevent_bus.signal(new MultiEvent(1, 'event')); // triggers both doA() and doB()\r\n```\r\n\r\n## Commands\r\nA `Command` is just a function that executes a task, and returns a `CommandResult`.\r\n\r\n#### Sample Usage\r\n```dart\r\nbasicCommand() {\r\n    doSomething();\r\n    return new CommandResult(events: [new DidSomethingEvent()]);\r\n}\r\n\r\nCommander commander = new Commander(event_bus);\r\n\r\n// This will call doSomething(), and fire a DidSomethingEvent\r\ncommander.execute(basicCommand());\r\n// Notice how 'basicCommand' is called before passing it to execute()\r\n```\r\n\r\n#### CommandResult\r\nAll the following properties of a `CommandResult` may be set in the constructor as named parameters (as shown above):\r\n\r\n* `return_value : dynamic` -\r\nThe return value of a command. What will be returned in a `Future` when `Commander.execute()` is called.\r\nWill return `null` by default.\r\n\r\n* `events : List<Event>` -\r\nA list of events the command should signal. `EventListeners` registered to the `Commander`'s `event_bus`\r\nwill be notified when the command is executed.\r\n\r\n* `undoable : bool` -\r\nWhether the command can be undone. If `true`, it must also assign an `EntityState` to the `state` parameter.\r\n\r\n* `state : EntityState` -\r\nA snapshot of the changes made by the command on some entity/object (described further below).\r\nOnly used when `undoable` is `true`.\r\n\r\n* `execute_first : List<CommandResult>` -\r\nA sequence of `CommandResults` that should be processed before the current command. Equivalent to calling\r\n`commander.executeSequence(execute_first)`.\r\n\r\n\r\n#### Commander\r\nThe object in charge of notifying the `EventBus` and Undo Stack of actions performed by `Commands`.\r\nEach `Commander` instance must be instantiated with the `EventBus` it will send `Events` to.\r\n\r\n* `execute(CommandResult result) : Future<dynamic>` -\r\nDespite it's name, this does not actually call your `Command` function (you must call it yourself, as demonstrated\r\nin the example above), it only propagates the result to the associated `EventBus` and logs any state changes to the\r\n`UndoRedoService`. It will return whatever your `Command` listed as its `return_value`, wrapped in a `Future`.\r\n\r\n> __Example:__ `commander.execute(squareCommand(2)).then((result) => result == 4)` will be `true`\r\n\r\n* `executeSequence(List<CommandResult> results) : Future< List<dynamic> >` -\r\nExecutes a sequence of `Commands` in the order given. Returns a `Future` with a list of each command's `return_value`\r\nin the order executed.\r\n\r\n> __Example:__ `commander.executeSequence([squareCommand(2), squareCommand(3)])` will return `[4, 9]` inside a `Future`\r\n\r\n* `event_bus : final EventBus` -\r\nThe `EventBus` all the command events will be sent to. Will have been defined in the constructor.\r\n\r\n* `undo_service : UndoRedoService` -\r\nThe object in charge of managing state. A new `UndoRedoService` instance is created for each `Commander`.\r\n\r\n\r\n### Undo/Redo\r\nUndo functionality can be implemented easily once state management behaviors are encapsulated as `Command` functions.\r\nThe undo service provided is a standard linear, stack-like implementation using the [Memento Pattern](http://en.wikipedia.org/wiki/Memento_pattern).\r\nModifications made after an `undo()` call will overwrite any possible `redo()` states.\r\n\r\n#### Undoable\r\nObjects must implement the `Undoable` interface to work with the `UndoRedoService`. It only requires one method to be implemented:\r\n\r\n `restoreTo(EntityState state) : void`\r\n\r\nThis ensures that the object can understand and update itself from `EntityStates` when when requested to do so.\r\n\r\n##### Sample Usage\r\n```dart\r\nclass MyEntity implements Undoable {\r\n    int id;\r\n    String description;\r\n\r\n    restoreTo(EntityState state) {\r\n        id = state.getOrDefaultTo('id', id);\r\n        description = state.getOrDefaultTo('description', description);\r\n    }\r\n}\r\n```\r\n\r\n#### EntityState\r\nThe 'memento' object used to store states on the Undo Stack. Requires a `Map` of an object's current state.\r\n\r\n##### Sample Usage\r\n```dart\r\nchangeDescriptionCommand(MyEntity entity, String new_description) {\r\n    entity.description = new_description;\r\n    EntityState<MyEntity> state = new EntityState.change(entity, {\r\n        'description': entity.description\r\n    });\r\n    return new CommandResult(undoable: true, state: state);\r\n}\r\n```\r\n\r\n* `EntityState<EntityType>({Undoable entity, Map<String, dynamic> state})` -\r\nDefault constructor, stores the original `entity` object alongside a `Map` of its properties.\r\n\r\n* `EntityState.change(Undoable entity_object, Map<String, dynamic> state)` -\r\nIdentical to default constructor, used to explicitly denote state _changes_ of an entity\r\n(i.e. only properties that have been changed should be included in the `state` map).\r\n\r\n* `diff(EntityState other) : EntityState` -\r\nReturns an `EntityState` with the values in `other` that are different from the current instance. _Example:_\r\n```dart\r\nvar stateA = new EntityState(entity: my_entity, state: {'name': 'hello', 'id': 1});\r\nvar stateB = new EntityState(entity: my_entity, state: {'name': 'world', 'id': 1});\r\n\r\nstateA.diff(stateB); // returns EntityState({'name': 'world'})\r\nstateB.diff(stateA); // returns EntityState({'name': 'hello'})\r\n```\r\n\r\n* `getOrDefaultTo(String property, dynamic default_value) : dynamic` -\r\nChecks whether the `EntityState` contains the `property` specified, otherwise returns the given `default_value`.\r\n\r\n* `contains(String property) : bool` -\r\nChecks whether the `EntityState` contains the `property` specified.\r\n\r\n* `forEach(void f(property, value))` - Iterates over each property-value pair in the `EntityState`\r\n\r\n* `properties : Set<String>` - The set of of the properties in the state\r\n\r\n* `entity : Undoable` - The object the EntityState represents.\r\n\r\n\r\n#### UndoRedoService\r\nEach `Commander` instance manages an `UndoRedoService`. If you want to be able to undo states for certain components\r\nseparately, you should create a new `Commander` for each of the components whose state you wish to track. `UndoRedoServices`\r\ncan also be instantiated directly for manual `EntityState` management.\r\n\r\n* `stack_size : int` - How many states are currently saved on the stack\r\n\r\n* `canUndo : bool` - Whether calling `undo()` would be a valid operation in the current state\r\n\r\n* `canRedo : bool` - Whether calling `redo()` would be a valid operation in the current state\r\n\r\n* `recordState(EntityState state) : void` - Saves an `EntityState` onto the stack. Does not need to be called directly\r\nwhen using a `Commander`\r\n\r\n* `clear() : void` - Removes all the states currently stored on the stack\r\n\r\n* `undo() : void` - Undoes the last command sent to the `Commander`\r\n\r\n* `redo() : void` - Reapplies the last command that was undone\r\n\r\n\r\n## Install\r\n\r\nAdd `event_commander` to your `pubspec.yaml` file to install it from pub:\r\n\r\n    dependencies:\r\n      event_commander: any\r\n\r\nor keep up with the latest developments on this git repo:\r\n\r\n    dependencies:\r\n      event_commander:\r\n        git: https://github.com/oblique63/EventCommander.git\r\n\r\nthen just run `$ pub get` and you'll be all set to go.\r\n\r\n__EventCommander__ has no additional/external dependencies, does not rely on `dart:mirrors`, and is compatible with both _client-side_ and _server-side_ code.\r\n\r\n### Import\r\nFor _Event Bus_ and _Event Queue_ features only:\r\n\r\n`import 'package:event_commander/event_bus.dart';`\r\n\r\n\r\nFor _Event Bus_, _Event Queue_, and _Command/Undo_ features:\r\n\r\n`import 'package:event_commander/event_commander.dart';`","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}